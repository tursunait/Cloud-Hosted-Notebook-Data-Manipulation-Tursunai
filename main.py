# -*- coding: utf-8 -*-
"""cloud.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BL1-dY8-nkVAe8fIcxffG8i4txREWrJW

# Customer purchase behavior - Electronic Sales Data
### By Tursunai Turumbekova
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/Amazon Sale Report.csv")

df

df.info()

# Calculate statistics by Category
category_stats = df.groupby("Category")[["Qty", "Amount"]].describe()
category_stats

# Count plot for Category
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x="Category", order=df["Category"].value_counts().index)
plt.title("Sales Count by Category")
plt.xlabel("Category")
plt.ylabel("Sales Count")
plt.xticks(rotation=45)
plt.show()

# Count plot for Status
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x="Status", order=df["Status"].value_counts().index)
plt.title("Sales Count by Status")
plt.xlabel("Status")
plt.ylabel("Sales Count")
plt.xticks(rotation=45)
plt.show()

# Histogram for Amount
plt.figure(figsize=(10, 6))
sns.histplot(df["Amount"], bins=30, kde=True)
plt.title("Distribution of Sales Amount")
plt.xlabel("Amount")
plt.ylabel("Frequency")
plt.show()

"""**Define "Top-Selling Items"**
To identify items with consistently high sales volumes or revenue.

Approach:
* Group data by SKU, Category, or Style to calculate total sales volume (Qty) and revenue (Amount).
* Define "top-selling items" based on the highest cumulative revenue or sales volume over a specified period (e.g., top 10% of items).
"""

# Aggregate data by SKU to get top-selling items
top_sellers = df.groupby("SKU").agg(
    total_qty=("Qty", "sum"), total_revenue=("Amount", "sum")
)
# Define a threshold for top-sellers (e.g., top 10%)
threshold = top_sellers["total_revenue"].quantile(0.9)
top_selling_skus = top_sellers[top_sellers["total_revenue"] >= threshold].index

top_sellers

# Filter dataset for top-selling items only
df_top_sellers = df[df["SKU"].isin(top_selling_skus)]
df_top_sellers

"""**Analyze Fulfillment and Courier Status for Top-Selling Items**
To examine the fulfillment methods and courier statuses associated with these top-selling items to identify any patterns in delivery performance.

Approach:
* Filter data for top-selling SKUs.
* Calculate the frequency of each Fulfillment and Courier Status for these items to determine common delivery outcomes.
"""

# Count fulfillment methods and courier statuses for top-selling items
fulfillment_counts = df_top_sellers["Fulfilment"].value_counts()
courier_status_counts = df_top_sellers["Courier Status"].value_counts()

"""**Measure Future Demand Trends by Courier Status**
To investigate if fulfillment and courier performance (e.g., delays, on-time deliveries) affect future sales volumes for top-selling products.

Approach:
* Calculate the average monthly or quarterly Qty for each SKU.
* Compare trends in sales volume for products with different courier statuses, such as items that had frequent delays vs. items with consistently successful deliveries.

"""

# Drop rows with NaT values in 'Date' after conversion
df_top_sellers.loc[:, "Date"] = df_top_sellers.dropna(subset=["Date"])

print(df_top_sellers["Date"].unique())
print(df_top_sellers["Date"].dtype)

# Use .loc to specify the assignment, which reduces the chance of the warning
df_top_sellers.loc[:, "Date"] = pd.to_datetime(
    df_top_sellers["Date"], format="%m-%d-%y", errors="coerce"
)

print(df_top_sellers["Date"].dtype)  # Should now show datetime64[ns]

df_top_sellers["Date"] = pd.to_datetime(
    df_top_sellers["Date"], format="%m-%d-%y", errors="coerce"
)

df_top_sellers["Month"] = df_top_sellers["Date"].dt.to_period("M")
monthly_sales = (
    df_top_sellers.groupby(["SKU", "Courier Status", "Month"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)

print(df_top_sellers["Courier Status"].unique())

# Option 1: Replace NaN with a placeholder, e.g., 'Unknown'
df_top_sellers["Courier Status"] = df_top_sellers["Courier Status"].fillna("Unknown")

# Option 2: Drop rows with NaN in 'Courier Status'
df_top_sellers = df_top_sellers.dropna(subset=["Courier Status"])

df_top_sellers

# Group by SKU, Courier Status, and Month to calculate monthly sales volume
monthly_sales = (
    df_top_sellers.groupby(["SKU", "Courier Status", "Date"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)
df_top_sellers

"""**Analyze Monthly Demand Trends by Courier Status**
To analyze if different courier statuses (e.g., "Shipped" vs. "Cancelled") affect future demand.

Approach:
* Calculate monthly sales volumes for each SKU based on their courier statuses.
* Observe if consistent cancellations or other statuses correlate with reduced future demand.
"""

# Group and calculate monthly sales volume for each SKU and Courier Status
daily_sales = (
    df_top_sellers.groupby(["SKU", "Courier Status", "Date"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)

# Display the resulting table
daily_sales

# Filter only completed orders (e.g., "Shipped")
completed_orders_daily = df_top_sellers[df_top_sellers["Courier Status"] == "Shipped"]

# Group by Date and calculate total quantity for completed orders
daily_sales_volume = completed_orders_daily.groupby("Date")["Qty"].sum()

# Filter only unfulfilled orders (e.g., "Cancelled" and "Unshipped")
unfulfilled_orders_daily = df_top_sellers[
    df_top_sellers["Courier Status"].isin(["Cancelled", "Unshipped"])
]

# Group by Date and Courier Status to calculate the frequency of unfulfilled orders
daily_unfulfilled_frequency = (
    unfulfilled_orders_daily.groupby(["Date", "Courier Status"])
    .size()
    .unstack(level=1)
    .fillna(0)
)

plt.figure(figsize=(14, 7))

# Plot completed sales volume (Shipped)
plt.plot(
    daily_sales_volume.index,
    daily_sales_volume,
    marker="o",
    color="green",
    label="Completed Sales Volume (Shipped)",
)

# Plot unfulfilled demand (Cancelled and Unshipped) on the same plot for comparison
for status in daily_unfulfilled_frequency.columns:
    plt.plot(
        daily_unfulfilled_frequency.index,
        daily_unfulfilled_frequency[status],
        marker="o",
        linestyle="--",
        label=f"Unfulfilled Demand ({status})",
    )

plt.title("Daily Completed Sales Volume and Unfulfilled Demand for Top-Selling Items")
plt.xlabel("Date")
plt.ylabel("Order Volume / Frequency")
plt.legend(title="Order Status")
plt.xticks(rotation=45)
plt.show()

"""**Compare Demand Trends for Different Fulfillment Methods**
To assess if different fulfillment methods have unique impacts on future demand, especially if associated with particular courier statuses.
Approach: Group data by both "Fulfillment" and "Courier Status" to calculate monthly demand for each combination.

Approach:
* To analyze how fulfillment methods (e.g., FBA or third-party logistics) impact demand trends. Combine this with courier statuses to observe if certain fulfillment methods experience more cancellations or delays, which could influence customer satisfaction.
"""

# Group by Fulfillment, Courier Status, and Date to calculate daily demand for each combination
daily_fulfillment_status = (
    df_top_sellers.groupby(["Fulfilment", "Courier Status", "Date"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)
# Display the resulting table
daily_fulfillment_status.head()

"""To get a clear view, we’ll create separate line plots for each fulfillment method, showing trends for "Shipped," "Cancelled," and "Unshipped" statuses within each method. This will allow us to compare how different fulfillment methods handle demand and if certain methods experience more cancellations."""

# List of unique fulfillment methods
fulfillment_methods = df_top_sellers["Fulfilment"].unique()

# Plot each fulfillment method in separate subplots
fig, axes = plt.subplots(nrows=len(fulfillment_methods), figsize=(14, 10), sharex=True)
fig.suptitle(
    "Daily Demand Trends by Fulfillment Method and Courier Status for Top-Selling Items"
)

for i, method in enumerate(fulfillment_methods):
    # Select data for the specific fulfillment method
    method_data = daily_fulfillment_status.loc[method]

    # Plot each courier status within the fulfillment method
    for status in method_data.columns:
        axes[i].plot(
            method_data.index, method_data[status], marker="o", label=f"{status}"
        )

    # Set plot titles and labels
    axes[i].set_title(f"Fulfillment Method: {method}")
    axes[i].set_ylabel("Order Volume / Frequency")
    axes[i].legend(title="Courier Status")

# Set x-axis label for the entire figure
plt.xlabel("Date")
plt.xticks(rotation=45)
plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()

# Group by Fulfillment, Courier Status, and Month to calculate monthly demand
monthly_fulfillment_status = (
    df_top_sellers.groupby(["Fulfilment", "Courier Status", "Month"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)
# Display the resulting table
monthly_fulfillment_status.head()

"""### **Demand Forecasting**
Forecasting future demand is essential for effective inventory and fulfillment planning. By analyzing past sales data, we can anticipate demand trends for top-selling items, helping to optimize resources and improve customer satisfaction.

In this analysis, we use Prophet, a powerful time series forecasting model, to project future demand based on completed sales (orders marked as "Shipped"). Prophet’s ability to handle seasonality and trends makes it ideal for identifying patterns in daily demand. This forecast will provide insights into expected sales volumes over the next 30 days, enabling better preparation for high-demand periods and reducing the risk of stockouts.
"""

# Filter data to include only 'Shipped' orders
shipped_orders = df_top_sellers[df_top_sellers["Courier Status"] == "Shipped"]

# Aggregate daily completed sales volume
daily_demand = shipped_orders.groupby("Date")["Qty"].sum()

# Alternatively, for monthly aggregation
monthly_demand = shipped_orders.groupby(shipped_orders["Date"].dt.to_period("M"))[
    "Qty"
].sum()

from prophet import Prophet

# Prepare data for Prophet
# Ensure Date is named 'ds' and Quantity is named 'y'
demand_data = daily_demand.reset_index()
demand_data.columns = ["ds", "y"]

# Initialize the model
model = Prophet()

# Fit the model on historical demand data
model.fit(demand_data)

# Create a DataFrame for future dates
future_dates = model.make_future_dataframe(
    periods=30
)  # Forecasting 30 days into the future

# Generate the forecast
forecast = model.predict(future_dates)

# Plot the forecast
model.plot(forecast)
plt.title("Demand Forecast for Top-Selling Items")
plt.xlabel("Date")
plt.ylabel("Forecasted Quantity")
plt.show()

"""### Demand Forecast Summary

The SARIMA forecast indicates a gradual decline in daily demand for top-selling items, suggesting a potential seasonal dip. Historical data aligns well with the initial forecast, enhancing model credibility. The confidence interval widens over time, reflecting increased uncertainty in longer-term predictions. This trend suggests that inventory and fulfillment operations could be adjusted accordingly. Regular updates with new data are recommended to refine accuracy and respond to any unexpected demand shifts.
"""
