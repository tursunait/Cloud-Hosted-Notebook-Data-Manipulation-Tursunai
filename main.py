# -*- coding: utf-8 -*-
"""cloud.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BL1-dY8-nkVAe8fIcxffG8i4txREWrJW

# Customer purchase behavior - Electronic Sales Data
### By Tursunai Turumbekova
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from prophet import Prophet

df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/Amazon Sale Report.csv")

df

df.info()

# Calculate statistics by Category
category_stats = df.groupby("Category")[["Qty", "Amount"]].describe()
category_stats

# Count plot for Category
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x="Category", order=df["Category"].value_counts().index)
plt.title("Sales Count by Category")
plt.xlabel("Category")
plt.ylabel("Sales Count")
plt.xticks(rotation=45)
plt.show()

# Count plot for Status
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x="Status", order=df["Status"].value_counts().index)
plt.title("Sales Count by Status")
plt.xlabel("Status")
plt.ylabel("Sales Count")
plt.xticks(rotation=45)
plt.show()

# Histogram for Amount
plt.figure(figsize=(10, 6))
sns.histplot(df["Amount"], bins=30, kde=True)
plt.title("Distribution of Sales Amount")
plt.xlabel("Amount")
plt.ylabel("Frequency")
plt.show()


# Aggregate data by SKU to get top-selling items
top_sellers = df.groupby("SKU").agg(
    total_qty=("Qty", "sum"), total_revenue=("Amount", "sum")
)
# Define a threshold for top-sellers (e.g., top 10%)
threshold = top_sellers["total_revenue"].quantile(0.9)
top_selling_skus = top_sellers[top_sellers["total_revenue"] >= threshold].index

top_sellers

# Filter dataset for top-selling items only
df_top_sellers = df[df["SKU"].isin(top_selling_skus)]
df_top_sellers


# Count fulfillment methods and courier statuses for top-selling items
fulfillment_counts = df_top_sellers["Fulfilment"].value_counts()
courier_status_counts = df_top_sellers["Courier Status"].value_counts()


# Drop rows with NaT values in 'Date' after conversion
df_top_sellers.loc[:, "Date"] = df_top_sellers.dropna(subset=["Date"])

print(df_top_sellers["Date"].unique())
print(df_top_sellers["Date"].dtype)

# Use .loc to specify the assignment, which reduces the chance of the warning
df_top_sellers.loc[:, "Date"] = pd.to_datetime(
    df_top_sellers["Date"], format="%m-%d-%y", errors="coerce"
)

print(df_top_sellers["Date"].dtype)  # Should now show datetime64[ns]

df_top_sellers["Date"] = pd.to_datetime(
    df_top_sellers["Date"], format="%m-%d-%y", errors="coerce"
)

df_top_sellers["Month"] = df_top_sellers["Date"].dt.to_period("M")
monthly_sales = (
    df_top_sellers.groupby(["SKU", "Courier Status", "Month"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)

print(df_top_sellers["Courier Status"].unique())

# Option 1: Replace NaN with a placeholder, e.g., 'Unknown'
df_top_sellers["Courier Status"] = df_top_sellers["Courier Status"].fillna("Unknown")

# Option 2: Drop rows with NaN in 'Courier Status'
df_top_sellers = df_top_sellers.dropna(subset=["Courier Status"])

df_top_sellers

# Group by SKU, Courier Status, and Month to calculate monthly sales volume
monthly_sales = (
    df_top_sellers.groupby(["SKU", "Courier Status", "Date"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)
df_top_sellers


# Group and calculate monthly sales volume for each SKU and Courier Status
daily_sales = (
    df_top_sellers.groupby(["SKU", "Courier Status", "Date"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)

# Display the resulting table
daily_sales

# Filter only completed orders (e.g., "Shipped")
completed_orders_daily = df_top_sellers[df_top_sellers["Courier Status"] == "Shipped"]

# Group by Date and calculate total quantity for completed orders
daily_sales_volume = completed_orders_daily.groupby("Date")["Qty"].sum()

# Filter only unfulfilled orders (e.g., "Cancelled" and "Unshipped")
unfulfilled_orders_daily = df_top_sellers[
    df_top_sellers["Courier Status"].isin(["Cancelled", "Unshipped"])
]

# Group by Date and Courier Status to calculate the frequency of unfulfilled orders
daily_unfulfilled_frequency = (
    unfulfilled_orders_daily.groupby(["Date", "Courier Status"])
    .size()
    .unstack(level=1)
    .fillna(0)
)

plt.figure(figsize=(14, 7))

# Plot completed sales volume (Shipped)
plt.plot(
    daily_sales_volume.index,
    daily_sales_volume,
    marker="o",
    color="green",
    label="Completed Sales Volume (Shipped)",
)

# Plot unfulfilled demand (Cancelled and Unshipped) on the same plot for comparison
for status in daily_unfulfilled_frequency.columns:
    plt.plot(
        daily_unfulfilled_frequency.index,
        daily_unfulfilled_frequency[status],
        marker="o",
        linestyle="--",
        label=f"Unfulfilled Demand ({status})",
    )

plt.title("Daily Completed Sales Volume and Unfulfilled Demand for Top-Selling Items")
plt.xlabel("Date")
plt.ylabel("Order Volume / Frequency")
plt.legend(title="Order Status")
plt.xticks(rotation=45)
plt.show()

daily_fulfillment_status = (
    df_top_sellers.groupby(["Fulfilment", "Courier Status", "Date"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)
# Display the resulting table
daily_fulfillment_status.head()

# List of unique fulfillment methods
fulfillment_methods = df_top_sellers["Fulfilment"].unique()

# Plot each fulfillment method in separate subplots
fig, axes = plt.subplots(nrows=len(fulfillment_methods), figsize=(14, 10), sharex=True)
fig.suptitle(
    "Daily Demand Trends by Fulfillment Method and Courier Status for Top-Selling Items"
)

for i, method in enumerate(fulfillment_methods):
    # Select data for the specific fulfillment method
    method_data = daily_fulfillment_status.loc[method]

    # Plot each courier status within the fulfillment method
    for status in method_data.columns:
        axes[i].plot(
            method_data.index, method_data[status], marker="o", label=f"{status}"
        )

    # Set plot titles and labels
    axes[i].set_title(f"Fulfillment Method: {method}")
    axes[i].set_ylabel("Order Volume / Frequency")
    axes[i].legend(title="Courier Status")

# Set x-axis label for the entire figure
plt.xlabel("Date")
plt.xticks(rotation=45)
plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()

# Group by Fulfillment, Courier Status, and Month to calculate monthly demand
monthly_fulfillment_status = (
    df_top_sellers.groupby(["Fulfilment", "Courier Status", "Month"])["Qty"]
    .sum()
    .unstack(level=1)
    .fillna(0)
)
# Display the resulting table
monthly_fulfillment_status.head()


# Filter data to include only 'Shipped' orders
shipped_orders = df_top_sellers[df_top_sellers["Courier Status"] == "Shipped"]

# Aggregate daily completed sales volume
daily_demand = shipped_orders.groupby("Date")["Qty"].sum()

# Alternatively, for monthly aggregation
monthly_demand = shipped_orders.groupby(shipped_orders["Date"].dt.to_period("M"))[
    "Qty"
].sum()


# Prepare data for Prophet
# Ensure Date is named 'ds' and Quantity is named 'y'
demand_data = daily_demand.reset_index()
demand_data.columns = ["ds", "y"]

# Initialize the model
model = Prophet()

# Fit the model on historical demand data
model.fit(demand_data)

# Create a DataFrame for future dates
future_dates = model.make_future_dataframe(
    periods=30
)  # Forecasting 30 days into the future

# Generate the forecast
forecast = model.predict(future_dates)

# Plot the forecast
model.plot(forecast)
plt.title("Demand Forecast for Top-Selling Items")
plt.xlabel("Date")
plt.ylabel("Forecasted Quantity")
plt.show()
